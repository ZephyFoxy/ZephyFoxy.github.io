---
published: false
title: Vulnserver Redux 1: Reverse Engineering the TRUN command
tags:
  - Exploit Development
  - Reverse Engineering
---

-----
# Intro
-----

At the time of writing, I am currently enrolled in Offensive Security's EXP-301/OSED course. One of the topics covered in the course is reverse engineering for bugs, which was one of my favorite modules. I wanted to get in a little extra practice so I came back to Vulnserver again, interested to see how complex it would be to reverse engineer it to discover the bugs.
<br/>

All testing was done on a Windows 10 v1910 VM with the firewall disabled, but Windows Defender enabled.

-----
# Reverse Engineering Vulnserver with WinDbg and IDA Free
-----
## Exploring vulnserver's functionality

We'll start by sending a generic network packet to vulnserver just to observe how it handles incoming data and understand code flow. The initial PoC is simple:
<center><img src="/assets/images/trun_re/1.png" /></center>  
<center><i><small>Figure 1 - Starter PoC</small></i></center>  
<br/>

Fire up WinDbg and then attach `vulnserver.exe`. We should see a list of imported DLLs right at the start, which has some valuable information for our first step in reverse engineering:
<center><img src="/assets/images/trun_re/2.png" /></center>  
<center><i><small>Figure 2 - Imported DLLs</small></i></center>  
<br/>

We start by seting a breakpoint at the `recv` function inside of `ws2_32.dll`. This is because `ws2_32.dll` is the library that vulnserver is using for network activity.
<center><img src="/assets/images/trun_re/3.png" /></center>  
<center><i><small>Figure 3 - Setting a breakpoint</small></i></center>  
<br/>

Execute the PoC, and observe how the breakpoint is hit in WinDbg:
<center><img src="/assets/images/trun_re/4.png" /></center>  
<center><i><small>Figure 4 - Breakpoint is hit</small></i></center>  
<br/>

We aren't really interested in stepping through this function, so use the `pt` command in WinDbg, which will continue execution until a `RET` instruction is encountered. Then use `p` to step a single instruction, and observe the address we land on:
<center><img src="/assets/images/trun_re/5.png" /></center>  
<center><i><small>Figure 5 - Returning to the func that called recv</small></i></center>  
<br/>

Now we open IDA Free and load up vulnserver. Once it is finished with analysis, press the `g` key to bring up a search box, and type the address displayed by WinDbg:
<center><img src="/assets/images/trun_re/6.png" /></center>  
<center><i><small>Figure 6 - The code that calls recv</small></i></center>  
<br/>

The instructions following the call to `recv` will perform the following actions:  
* Move the contents of `EAX` onto the stack
* Compare this value to `0`
* Make a jump if this value is *less than or equal to* `0`

Let's see what is in `EAX`:
<center><img src="/assets/images/trun_re/7.png" /></center>  
<center><i><small>Figure 7 - Value of EAX</small></i></center>  
<br/>

The value is 0xFFFFFFFF, which represents a `-1`, which means that the jump should be taken. We'll confirm this in WinDbg:
<center><img src="/assets/images/trun_re/8.png" /></center>  
<center><i><small>Figure 1 - "br=1" means the jump is taken</small></i></center>  
<br/>

We come to the next code block in IDA which tries to compare the mystery value on the stack to `0` once again, causing execution to branch again. Following this second branch in IDA, we find this troubling code:
<center><img src="/assets/images/trun_re/11.png" /></center>  
<center><i><small>Figure 11 - Error handling code</small></i></center>  
<br/>

Looks like a socket error occurred. Following execution beyond here just leads us to a loop that redirects execution back to the `recv` call, waiting for more incoming user input.

We'll go back to the code block in IDA where we saw the call to `recv` and trace where code exection would go if we *didn't* have a socket error:
<center><img src="/assets/images/trun_re/12.png" /></center>  
<center><i><small>Figure 12 - Looking for content in the buffer</small></i></center>  
<br/>

The code in this block is setting up a few arguments before calling `strncmp`.
* Moving the value `5` on the stack
* Moving the offset to the ascii string "HELP " on the stack
* Moving an unknown value into `EAX`, and then moving it onto the stack

`strncmp` takes 3 arguments; two strings to compare, and the number of bytes to compare. This code is going to see if the mystery value is the same as "HELP " with a trailing space. After the call completes, the code tests to see if `EAX` is equal to itself, and if it is not, execution continues to more code blocks doing similar comparisons:
<center><img src="/assets/images/trun_re/13.png" /></center>  
<center><i><small>Figure 13 - Another string check</small></i></center>  
<br/>

