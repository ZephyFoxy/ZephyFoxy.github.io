---
published: false
title: Vulnserver Redux 1: Reverse Engineering the TRUN command
tags:
  - Exploit Development
  - Reverse Engineering
---

-----
# Intro
-----

At the time of writing, I am currently enrolled in Offensive Security's EXP-301/OSED course. One of the topics covered in the course is reverse engineering for bugs, which was one of my favorite modules. I wanted to get in a little extra practice so I came back to Vulnserver again, interested to see how complex it would be to reverse engineer it to discover the bugs.
<br/>

All testing was done on a Windows 10 v1910 VM with the firewall disabled, but Windows Defender enabled.

-----
# Reverse Engineering Vulnserver with WinDbg and IDA Free
-----
## Exploring vulnserver's functionality

We'll start by sending a generic network packet to vulnserver just to observe how it handles incoming data and understand code flow. The initial PoC is simple:
<center><img src="/assets/images/trun_re/1.png" /></center>  
<center><i><small>Figure 1 - Starter PoC</small></i></center>  
<br/>

Fire up WinDbg and then attach `vulnserver.exe`. We should see a list of imported DLLs right at the start, which has some valuable information for our first step in reverse engineering:
<center><img src="/assets/images/trun_re/2.png" /></center>  
<center><i><small>Figure 2 - Imported DLLs</small></i></center>  
<br/>

We start by seting a breakpoint at the `recv` function inside of `ws2_32.dll`. This is because `ws2_32.dll` is the library that vulnserver is using for network activity.
<center><img src="/assets/images/trun_re/3.png" /></center>  
<center><i><small>Figure 3 - Setting a breakpoint</small></i></center>  
<br/>

Execute the PoC, and observe how the breakpoint is hit in WinDbg:
<center><img src="/assets/images/trun_re/4.png" /></center>  
<center><i><small>Figure 4 - Breakpoint is hit</small></i></center>  
<br/>

We aren't really interested in stepping through this function, so use the `pt` command in WinDbg, which will continue execution until a `RET` instruction is encountered. Then use `p` to step a single instruction, and observe the address we land on:
<center><img src="/assets/images/trun_re/5.png" /></center>  
<center><i><small>Figure 5 - Returning to the func that called recv</small></i></center>  
<br/>

Now we open IDA Free and load up vulnserver. Once it is finished with analysis, press the `g` key to bring up a search box, and type the address displayed by WinDbg:
<center><img src="/assets/images/trun_re/6.png" /></center>  
<center><i><small>Figure 6 - The code that calls recv</small></i></center>  
<br/>

The instructions following the call to `recv` will perform the following actions:  
* Move the contents of `EAX` onto the stack
* Compare this value to `0`
* Make a jump if this value is *less than or equal to* `0`

Let's see what is in `EAX`:
<center><img src="/assets/images/trun_re/7.png" /></center>  
<center><i><small>Figure 7 - Value of EAX</small></i></center>  
<br/>

The value is 0xFFFFFFFF, which represents a `-1`, which means that the jump should be taken. We'll confirm this in WinDbg:
<center><img src="/assets/images/trun_re/8.png" /></center>  
<center><i><small>Figure 8 - "br=1" means the jump is taken</small></i></center>  
<br/>

We come to the next code block in IDA which tries to compare the mystery value on the stack to `0` once again, causing execution to branch again. Following this second branch in IDA, we find this troubling code:
<center><img src="/assets/images/trun_re/9.png" /></center>  
<center><i><small>Figure 9 - Error handling code</small></i></center>  
<br/>

Looks like a socket error occurred. Following execution beyond here just leads us to a loop that redirects execution back to the `recv` call, waiting for more incoming user input.

We'll go back to the code block in IDA where we saw the call to `recv` and trace where code exection would go if we *didn't* have a socket error:
<center><img src="/assets/images/trun_re/10.png" /></center>  
<center><i><small>Figure 10 - Looking for content in the buffer</small></i></center>  
<br/>

The code in this block is setting up a few arguments before calling `strncmp`.
* Moving the value `5` on the stack
* Moving the offset to the ascii string "HELP " on the stack
* Moving an unknown value into `EAX`, and then moving it onto the stack

`strncmp` takes 3 arguments; two strings to compare, and the number of bytes to compare. This code is going to see if the mystery value is the same as "HELP " with a trailing space. After the call completes, the code tests to see if `EAX` is equal to itself, and if it is not, execution continues to more code blocks doing similar comparisons:
<center><img src="/assets/images/trun_re/16.png" /></center>  
<center><i><small>Figure 11 - Another string check</small></i></center>  
<br/>

We'll re-run the PoC with the breakpoint to `recv` still set, and after it returns, we'll manually set `EAX` to a value that is greater than 0 to manipulate code flow:
<center><img src="/assets/images/trun_re/11.png" /></center>  
<center><i><small>Figure 12 - Chaning the value of EAX</small></i></center>  
<br/>

Keep stepping through the code in WinDbg until we reach the call to `strncmp`, and then dump the stack to see the arguments:
<center><img src="/assets/images/trun_re/13.png" /></center>  
<center><i><small>Figure 13 - Args to strncmp</small></i></center>  
<br/>

The first argument is supposed to be our supplied buffer, but since we're still having unexplained socket errors, no buffer was received. This would cause the `strncmp` to return a non-zero value since the strings don't match, starting the flow of additional comparisons.

In C or C++, this would likely be a nested "if/else" statement comparing user-supplied input to several strings to look for a match.

With our new knowledge, we'll change up our PoC to add "HELP " to the start of the buffer to trigger a successful comparison. It was also at this point that I suspected that having a breakpoint on `recv` may be causing socket errors for an unknown reason, so I cleared all breakpoints with `bc *`, and the set a breakpoint on the call to `strncmp` instead:
<center><img src="/assets/images/trun_re/18.png" /></center>  
<center><i><small>Figure 14 - Updated buffer</small></i></center>  
<br/>

Landing on this call, we'll dump the stack again to see what the arguments are this time:
<center><img src="/assets/images/trun_re/21.png" /></center>  
<center><i><small>Figure 15 - Args to strncmp take 2</small></i></center>  
<br/>

We can see now that the first 5 bytes of our buffer are being checked to see if they match "HELP ". The comparison should return `0` to denote that the two strings are equal, so code will *not* branch and instead continue normally. Follow the `red arrow` on the code block and we should see this:
<center><img src="/assets/images/trun_re/23.png" /></center>  
<center><i><small>Figure 16 - Executing the received command</small></i></center>  
<br/>

Looks like some different code is being executed based on the received command. We see some arguments being prepared before a call to `send`, most notable of which is a long string. It appears that this is going to send us a message back based on our input. If we want to confirm this theory we can modify our PoC like so:
<center><img src="https://i.imgur.com/aFNanbW.png" /></center>  
<center><i><small>Figure 17 - Receiving output</small></i></center>  
<br/>

We need two `s.recv` calls due to the fact that vulnserver prints out a line of text upon connection. We don't print it because we don't care about it. The second `s.recv` will be put into a variable and then printed:
<center><img src="/assets/images/trun_re/24.png" /></center>  
<center><i><small>Figure 18 - Confirming returned output</small></i></center>  
<br/>

